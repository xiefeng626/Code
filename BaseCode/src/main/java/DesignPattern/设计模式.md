# 										设计模式

## 分类

> + **创建型模式** ：**对象实例化的模式，创建型模式用于解耦对象的实例化过程。**
>
> + **结构型模式**：**把类或对象结合在一起形成一个更大的结构**
>
> + **行为型模式**：**类和对象如何交互，及划分责任和算法**

## 类之间的关系6：

> + 依赖：类B作为参数被类A在某个method方法中使用； 耦合度最低
>
> + 关联 ：将一个类的对象作为另一个类的成员变量 （**可以**多对多（相互关联））
>
> + 聚合：是关联的一种，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在
>
>   ​			即不是相互关联的 
>
> + 组合：也是关联的一种，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。
>
> + 泛化：继承  耦合度最高（和实现一样）
>
> + 实现：接口与实现类  耦合度最高

## 派生与继承

> + 继承与派生是同一个过程从不同的角度看：
>   + 保持已有类的特性而构成新类的过程称为继承
>   + 在已有类的基础上新增自己的特性而产生新类的过程称为派生



## 面向对象设计原则7

> + 开闭原则：对扩展开放，对修改关闭
> + 里替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。（因为重写父类方法会产生一些意外的错误 即如果再构造函数里面调用非finally方法  他会去调用子类方法 而子类方法不保证父类中可以正确的运行）
> + 依赖倒置原则：要面向接口编程，不要面向实现编程。
> + 单一职责原则：规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
> + 接口隔离原则：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用
> + 迪米特法则：只与你的直接朋友交谈，不跟“陌生人”说话。（“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。）
> + 合用复用原则：要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现
>
> **总结**：这 7 种设计原则是软件[设计模式](http://c.biancheng.net/design_pattern/)必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。
>
> 

## 1.1单例模型

------

> 单例模式就是 这个类只有一个对象 
>
> 即他的构造函数是私有的 只能他自己构造 外部是不能new这个对象的
>
> 他给外部提供了一个接口 [**HungrySingleton.getInstance**]()外部通过这个接口可以访问到这个唯一的对象
>
> ```java
> class HungrySingleton
> {
>  private static final HungrySingleton instance=new HungrySingleton();
>  private HungrySingleton(){}
>  public static HungrySingleton getInstance()
>  {
>      return instance;
>  }
> }
> ```
>
> 

## 1.2原型模式

> 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象



## tips:可以通过实例对象掉用静态方法  但是不建议



## 1.3工厂模式

------

> [工厂方法模式](http://c.biancheng.net/view/1348.html)属于类创建型模式，其他的全部属于对象创建型模式
>
> 定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离
>
> + **简单工厂**：创建工厂（根据你提供的产品）去选择相应的工厂创建产品 
>
>   + 一个工厂通过其中的方法接受不同的参数 从而创建不同的产品
>
>   + 缺点：工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
>
>     违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
>
>     简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。





简单工厂：工厂不是抽象的，产品是抽象的 只能在固定的工厂生产产品，但是如果该工厂生产不了的话。就得在该工厂修改代码，违背了开闭原则，使维护变得更加困难。（每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类）

抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。

- 抽象的工厂
  - 具体实现一个工厂只对应一个产品（产品是不可扩展的）



抽象工厂：工厂是抽象的，产品也是抽象的。如果此时生产新的产品只需要新建新的。即：选择工厂，再选择产品这样的层级关系

----

+ 工厂 
  +  牧场：
    + 动物
    + 蔬菜
  + 农场：
    + 动物
    + 蔬菜

----

工厂 

+  牧场：
  + 动物
  + 蔬菜
+ 农场：
  + 动物
  + 蔬菜
  + C品               不满足开闭原则
+ X厂                      满足开闭原则
  + A品
  + B品

----

缺点：新增一个产品**族**的时候满足开闭原则 新增一个新的产品的时候不满足开闭原则

## 建造者模式

------

构建与表示分离

​	同样的构建不同的表示



使用场景：

+ 对象有复杂的内部结构
+ 当一些基本组件不会变，而组合经常变化的时候
+ 当成生的对象内部属性本身相互依赖的时候



组成：

+ 抽象建造者

+ 具体建造者

- 指挥者

- 产品

